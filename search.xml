<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[rfm深入浅出]]></title>
    <url>%2F%E8%90%A5%E9%94%80%2Frfm%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%2F</url>
    <content type="text"><![CDATA[RFM模型概述 RFM模型是网点衡量当前用户价值和客户潜在价值的重要工具和手段。 RFM是Rencency（最近一次消费），Frequency（消费频率）、Monetary（消费金额） R：(Recency)最近一次消费时间距离天数；当天的日期-每个客户的最后一次交易日期＝客户最后一次交易距离天数 F：(Frequency)消费频率、购买次数 M：(Monetary)消费总金额 客单价和累计消费金额的区别： 比如说一个人在一段时间里面买了3笔订单，每一笔都是100元，那他的客单价就是100，累计消费金额就是300； 与金额相关的字段： 客单价=消费总金额/客户数；（人均累计消费） 件单价=消费总金额/商品件数； 平均每次购买金额=总金额/购买次数；一个客户若一天内购买多单，只能算一次 如图所示： R值: Rencency（最近一次消费） 消费指的是客户在店铺消费最近一次和上一次的时间间隔，理论上R值越小的客户是价值越高的客户，即对店铺的回购几次最有可能产生回应。目前网购便利，顾客已经有了更多的购买选择和更低的购买成本，去除地域的限制因素，客户非常容易流失，因此CRM操盘手想要提高回购率和留存率，需要时刻警惕R值。 如下图，某零食网店用户最近一次消费R值分布图（时间截至2016年12月31日）： 1、客户R值呈规律性的“波浪形”分布，时间越长，波浪越小； 2、最近一年内用户占比50%（真的很巧）；数据分析：这个数据根据向行业内专业人员请教，已经是比较理想了的。说明每引入2个客户，就有一位用户在持续购买。说明店铺复购做的比较好，R值在不断的变为0。 F值：Frequency（消费频率） 消费频率是客户在固定时间内的购买次数（一般是1年）。但是如果实操中实际店铺由于受品类宽度的原因，比如卖3C产品，耐用品等即使是忠实粉丝用户也很难在1年内购买多次。所以，一般店铺在运营RFM模型时，会把F值的时间范围去掉，替换成累计购买次数。 如下图，某零食网店用户购买频次图（如1个客户在1天内购买多笔订单，则自动合并为1笔订单）： 1、购买1次（新客户）占比为65.5%，产生重复购买（老客户）的占比为34.4%；2、购买3次及以上（成熟客户）的占比为17%，购买5次及以上（忠实客户）的占比为6%。 数据分析：影响复购的核心因素是商品，因此复购不适合做跨类目比较。比如食品类目和美妆类目：食品是属于“半标品”，产品的标品化程度越高，客户背叛的难度就越小，越难形成忠实用户；但是相对美妆，食品又属于易耗品，消耗周期短，购买频率高，相对容易产生重复购买，因此跨类目复购并不具有可比性。 M值：Monetary（消费金额） M值是RFM模型中相对于R值和F值最难使用，但最具有价值的指标。大家熟知的“二八定律”（又名“帕雷托法则”）曾作出过这样的解释：公司80%的收入来自于20%的用户。这个数据我在自己所从事的公司总都得到过验证！可能有些店铺不会那么精确，一般也很会控制在30%客户贡献70%收入，或者40%贡献60%收入。理论上M值和F值是一样的，都带有时间范围，指的是一段时间（通常是1年）内的消费金额，在工作中我认为对于一般店铺的类目而言，产品的价格带都是比较单一的，比如：同一品牌美妆类，价格浮动范围基本在某个特定消费群的可接受范围内，加上单一品类购买频次不高，所以对于一般店铺而言，M值对客户细分的作用相对较弱。所以我认为用店铺的累计购买金额和平均客单价替代传统的M值能更好的体现客户消费金额的差异。 教大家一个特别简单的累积金额划分方法：将1/2的客单价作为累积消费金额的分段，比如客单价是300元，则按照150元进行累计消费金额分段，得出十个分段。现以国内某知名化妆品店铺举例，店铺平均客单为160元，因此以80元作为间隔将累积消费金额分段，从表中可以很明显发现，累计消费160元以下用户占比为65.5%（近2/3），贡献的店铺收入比例只占31.6%（近1/3），具体如下： ##二、基于RFM模型的实践应用##作为CRM操盘手，主要有两种方法来分析RFM模型的结果：用基于RFM模型的划分标准来进行客户细分，用基于RFM模型的客户评分来进行客户细分。1、基于RFM模型进行客户细分CRM实操时可以选择RFM模型中的1-3个指标进行客户细分，如下表所示。 切记细分指标需要在自己可操控的合理范围内，并非越多越好，一旦用户细分群组过多，一来会给自己的营销方案执行带来较大的难度，而来可能会遗漏用户群或者对同个用户造成多次打扰。 最终选择多少个指标有两个参考标准：店铺的客户基数，店铺的商品和客户结构。店铺的客户基数： 在店铺客户一定的情况下选择的维度越多，细分出来每一组的用户越少。对于店铺基数不大（5万以下客户数）的店铺而言，选择1-2个维度进行细分即可。对于客户超过50万的大卖家而言可以选择2-3个指标。 店铺的商品和客户结构： 如果在店铺的商品层次比较单一，客单价差异幅度不大的情况下，购买频次（F值）和消费金额（M值）高度相关的情况下，可以只选择比较容易操作的购买频次（F值）代替消费金额（M值）。对于刚刚开店还没形成客户粘性的店铺，则可以放弃购买频次（F值），直接用最后一次消费（R值）或者消费金额（M值）。 应用：（1）会员日专享活动，可以刺激用户消费，通过消费获得更高的特权（2）积分换券、积分抵现、积分换购等（3）企业联合活动 ##通过RFM模型评分后输出目标用户## 除了直接用RFM模型对用户进行分组之外，还有一种常见的方法是利用RFM模型的三个属性对客户进行打分，通过打分确定每个用户的质量，最终筛选出自己的目标用户。RFM模型评分主要有三个部分：1、确定RFM三个指标的分段和每个分段的分值；2、计算每个客户RFM三个指标的得分；3、计算每个客户的总得分，并且根据总得分筛选出优质的客户 比如，实操的过程中一般每个指标分为3-5段，其中R值可以根据开店以来的时间和产品的回购周期来判定，F值根据现有店铺的平均购买频次，M值可参考上文客单价的分段指标。 举个例子： 确认RFM的分段和对应分段的分值之后，就可以按照用户情况对应进行打分。 ##其它##复购（F值≥2）不包括第一次成交的金额、订单数、件数、客单价、件单价，只从第二次开始计算。 新老客户：新客户表示在曾经没有购买过，但在时间段内第一次购买的客户；老客户表示在曾经有购买过，但在时间段内有回购的客户。 新客数：某个时间段内只购买了一次; 复购新客数：某个时间段内重复购买多次（多次购买）;新客数包括复购新客数 ##图例##RFM模型： R值分析：R M值指标，会员等级： F值分析：F M值指标，会员等级： M值分析：F M值指标，会员等级： 回购周期分析：R F M值指标： 回购周期分析：会员等级 ###客户结构：分层算法,评分### 分层算法用户评分阈值复购 ###根据rfm,做用户画像，分层用户类型###1.0客户类型（R F M值变化趋势）2.0客户价值（R M值变化趋势）3.0品牌忠诚度（F值变化趋势）4.0查看-单个用户详情5.0老客活跃度6.0日趋势时段分析 ##Axure项目实例## rfm店铺项目实例]]></content>
      <categories>
        <category>营销</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Pandas最全解析]]></title>
    <url>%2FPandas%2FPandas%2F</url>
    <content type="text"><![CDATA[一、生成数据表1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用： 12import numpy as np import pandas as pd 2、导入CSV或者xlsx文件： 12df = pd.DataFrame(pd.read_csv(‘name.csv’,header=1)) df = pd.DataFrame(pd.read_excel(‘name.xlsx’)) 3、用pandas创建数据表： 1234567df = pd.DataFrame(&#123;&quot;id&quot;:[1001,1002,1003,1004,1005,1006], &quot;date&quot;:pd.date_range(&apos;20130102&apos;, periods=6), &quot;city&quot;:[&apos;Beijing &apos;, &apos;SH&apos;, &apos; guangzhou &apos;, &apos;Shenzhen&apos;, &apos;shanghai&apos;, &apos;BEIJING &apos;], &quot;age&quot;:[23,44,54,32,34,32], &quot;category&quot;:[&apos;100-A&apos;,&apos;100-B&apos;,&apos;110-A&apos;,&apos;110-C&apos;,&apos;210-A&apos;,&apos;130-F&apos;], &quot;price&quot;:[1200,np.nan,2133,5433,np.nan,4432]&#125;, columns =[&apos;id&apos;,&apos;date&apos;,&apos;city&apos;,&apos;category&apos;,&apos;age&apos;,&apos;price&apos;]) 二、数据表信息查看1、维度查看： 1df.shape 2、数据表基本信息（维度、列名称、数据格式、所占空间等）： 1df.info() 3、每一列数据的格式： 1df.dtypes 4、某一列格式： 1df[‘B’].dtype 5、空值： 1df.isnull() 6、查看某一列空值： 1df.isnull() 7、查看某一列的唯一值： 1df[‘B’].unique() 8、查看数据表的值： 1df.values 9、查看列名称： 1df.columns 10、查看前10行数据、后10行数据： 12df.head() #默认前10行数据 df.tail() #默认后10 行数据 三、数据表清洗1、用数字0填充空值： 1df.fillna(value=0) 2、使用列prince的均值对NA进行填充： 1df[‘prince’].fillna(df[‘prince’].mean()) 3、清楚city字段的字符空格： 1df[‘city’]=df[‘city’].map(str.strip) 4、大小写转换： 1df[‘city’]=df[‘city’].str.lower() 5、更改数据格式： 1df[‘price’].astype(‘int’) 6、更改列名称： 1df.rename(columns=&#123;‘category’: ‘category-size’&#125;) 7、删除后出现的重复值： 1df[‘city’].drop_duplicates() 8、删除先出现的重复值： 1df[‘city’].drop_duplicates(keep=’last’) 9、数据替换： 1df[‘city’].replace(‘sh’, ‘shanghai’) 四、数据预处理 1234df1=pd.DataFrame(&#123;&quot;id&quot;:[1001,1002,1003,1004,1005,1006,1007,1008], &quot;gender&quot;:[&apos;male&apos;,&apos;female&apos;,&apos;male&apos;,&apos;female&apos;,&apos;male&apos;,&apos;female&apos;,&apos;male&apos;,&apos;female&apos;],&quot;pay&quot;:[&apos;Y&apos;,&apos;N&apos;,&apos;Y&apos;,&apos;Y&apos;,&apos;N&apos;,&apos;Y&apos;,&apos;N&apos;,&apos;Y&apos;,],&quot;m-point&quot;:[10,12,20,40,40,40,30,20]&#125;) 1 23 41、数据表合并1.1 mergedf_inner=pd.merge(df,df1,how=’inner’) # 匹配合并，交集df_left=pd.merge(df,df1,how=’left’) #df_right=pd.merge(df,df1,how=’right’)df_outer=pd.merge(df,df1,how=’outer’) #并集1 23 41.2 appendresult = df1.append(df2)1 这里写图片描述 1.3 joinresult = left.join(right, on=’key’)1 这里写图片描述 1.4 concatpd.concat(objs, axis=0, join=’outer’, join_axes=None, ignore_index=False, keys=None, levels=None, names=None, verify_integrity=False, copy=True)1 23 objs︰ 一个序列或系列、 综合或面板对象的映射。如果字典中传递，将作为键参数，使用排序的键，除非它传递，在这种情况下的值将会选择 （见下文）。任何没有任何反对将默默地被丢弃，除非他们都没有在这种情况下将引发 ValueError。axis: {0，1，…}，默认值为 0。要连接沿轴。join: {‘内部’、 ‘外’}，默认 ‘外’。如何处理其他 axis(es) 上的索引。联盟内、 外的交叉口。ignore_index︰ 布尔值、 默认 False。如果为 True，则不要串联轴上使用的索引值。由此产生的轴将标记 0，…，n-1。这是有用的如果你串联串联轴没有有意义的索引信息的对象。请注意在联接中仍然受到尊重的其他轴上的索引值。join_axes︰ 索引对象的列表。具体的指标，用于其他 n-1 轴而不是执行内部/外部设置逻辑。keys︰ 序列，默认为无。构建分层索引使用通过的键作为最外面的级别。如果多个级别获得通过，应包含元组。levels︰ 列表的序列，默认为无。具体水平 （唯一值） 用于构建多重。否则，他们将推断钥匙。names︰ 列表中，默认为无。由此产生的分层索引中的级的名称。verify_integrity︰ 布尔值、 默认 False。检查是否新的串联的轴包含重复项。这可以是相对于实际数据串联非常昂贵。副本︰ 布尔值、 默认 True。如果为 False，请不要，不必要地复制数据。 例子：1.frames = [df1, df2, df3]2.result = pd.concat(frames)这里写图片描述 2、设置索引列df_inner.set_index(‘id’) 3、按照特定列的值排序：df_inner.sort_values(by=[‘age’]) 4、按照索引列排序：df_inner.sort_index() 5、如果prince列的值&gt;3000，group列显示high，否则显示low：df_inner[‘group’] = np.where(df_inner[‘price’] &gt; 3000,’high’,’low’) 6、对复合多个条件的数据进行分组标记df_inner.loc[(df_inner[‘city’] == ‘beijing’) &amp; (df_inner[‘price’] &gt;= 4000), ‘sign’]=1 7、对category字段的值依次进行分列，并创建数据表，索引值为df_inner的索引列，列名称为category和sizepd.DataFrame((x.split(‘-‘) for x in df_inner[‘category’]),index=df_inner.index,columns=[‘category’,’size’])) 8、将完成分裂后的数据表和原df_inner数据表进行匹配df_inner=pd.merge(df_inner,split,right_index=True, left_index=True) 五、数据提取主要用到的三个函数：loc,iloc和ix，loc函数按标签值进行提取，iloc按位置进行提取，ix可以同时按标签和位置进行提取。 1、按索引提取单行的数值df_inner.loc[3] 2、按索引提取区域行数值df_inner.iloc[0:5] 3、重设索引df_inner.reset_index() 4、设置日期为索引df_inner=df_inner.set_index(‘date’) 5、提取4日之前的所有数据df_inner[:’2013-01-04’] 6、使用iloc按位置区域提取数据df_inner.iloc[:3,:2] #冒号前后的数字不再是索引的标签名称，而是数据所在的位置，从0开始，前三行，前两列。 7、适应iloc按位置单独提起数据df_inner.iloc[[0,2,5],[4,5]] #提取第0、2、5行，4、5列 8、使用ix按索引标签和位置混合提取数据df_inner.ix[:’2013-01-03’,:4] #2013-01-03号之前，前四列数据 9、判断city列的值是否为北京df_inner[‘city’].isin([‘beijing’]) 10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来df_inner.loc[df_inner[‘city’].isin([‘beijing’,’shanghai’])] 11、提取前三个字符，并生成数据表pd.DataFrame(category.str[:3]) 六、数据筛选使用与、或、非三个条件配合大于、小于、等于对数据进行筛选，并进行计数和求和。 1、使用“与”进行筛选df_inner.loc[(df_inner[‘age’] &gt; 25) &amp; (df_inner[‘city’] == ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]] 2、使用“或”进行筛选df_inner.loc[(df_inner[‘age’] &gt; 25) | (df_inner[‘city’] == ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘age’]) 3、使用“非”条件进行筛选df_inner.loc[(df_inner[‘city’] != ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘id’]) 4、对筛选后的数据按city列进行计数df_inner.loc[(df_inner[‘city’] != ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘id’]).city.count() 5、使用query函数进行筛选df_inner.query(‘city == [“beijing”, “shanghai”]’) 6、对筛选后的结果按prince进行求和df_inner.query(‘city == [“beijing”, “shanghai”]’).price.sum() 七、数据汇总主要函数是groupby和pivote_table 1、对所有的列进行计数汇总df_inner.groupby(‘city’).count() 2、按城市对id字段进行计数df_inner.groupby(‘city’)[‘id’].count() 3、对两个字段进行汇总计数df_inner.groupby([‘city’,’size’])[‘id’].count() 4、对city字段进行汇总，并分别计算prince的合计和均值df_inner.groupby(‘city’)[‘price’].agg([len,np.sum, np.mean]) 八、数据统计数据采样，计算标准差，协方差和相关系数 1、简单的数据采样df_inner.sample(n=3) 2、手动设置采样权重weights = [0, 0, 0, 0, 0.5, 0.5]df_inner.sample(n=2, weights=weights) 3、采样后不放回df_inner.sample(n=6, replace=False) 4、采样后放回df_inner.sample(n=6, replace=True) 5、 数据表描述性统计df_inner.describe().round(2).T #round函数设置显示小数位，T表示转置 6、计算列的标准差df_inner[‘price’].std() 7、计算两个字段间的协方差df_inner[‘price’].cov(df_inner[‘m-point’]) 8、数据表中所有字段间的协方差df_inner.cov() 9、两个字段的相关性分析df_inner[‘price’].corr(df_inner[‘m-point’]) #相关系数在-1到1之间，接近1为正相关，接近-1为负相关，0为不相关 10、数据表的相关性分析df_inner.corr() 九、数据输出分析后的数据可以输出为xlsx格式和csv格式 1、写入Exceldf_inner.to_excel(‘excel_to_python.xlsx’, sheet_name=’bluewhale_cc’) 2、写入到CSVdf_inner.to_csv(‘excel_to_python.csv’)]]></content>
      <categories>
        <category>Pandas</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RBAC最全解析]]></title>
    <url>%2FRBAC%2FRBAC%2F</url>
    <content type="text"><![CDATA[权限系统与RBAC模型概述 RBAC（Role-Based Access Control ）基于角色的访问控制。 在20世纪90年代期间，大量的专家学者和专门研究单位对RBAC的概念进行了深入研究，先后提出了许多类型的RBAC模型，其中以美国George Mason大学信息安全技术实验室（LIST）提出的RBAC96模型最具有系统性，得到普遍的公认。 RBAC认为权限的过程可以抽象概括为：判断【Who是否可以对What进行How的访问操作（Operator）】这个逻辑表达式的值是否为True的求解过程。 即将权限问题转换为Who、What、How的问题。who、what、how构成了访问权限三元组。 RBAC支持公认的安全原则：最小特权原则、责任分离原则和数据抽象原则。 最小特权原则得到支持，是因为在RBAC模型中可以通过限制分配给角色权限的多少和大小来实现，分配给与某用户对应的角色的权限只要不超过该用户完成其任务的需要就可以了。责任分离原则的实现，是因为在RBAC模型中可以通过在完成敏感任务过程中分配两个责任上互相约束的两个角色来实现，例如在清查账目时，只需要设置财务管理员和会计两个角色参加就可以了。数据抽象是借助于抽象许可权这样的概念实现的，如在账目管理活动中，可以使用信用、借方等抽象许可权，而不是使用操作系统提供的读、写、执行等具体的许可权。但RBAC并不强迫实现这些原则，安全管理员可以允许配置RBAC模型使它不支持这些原则。因此，RBAC支持数据抽象的程度与RBAC模型的实现细节有关。RBAC96是一个模型族，其中包括RBAC0~RBAC3四个概念性模型。 1、基本模型RBAC0定义了完全支持RBAC概念的任何系统的最低需求。 2、RBAC1和RBAC2两者都包含RBAC0，但各自都增加了独立的特点，它们被称为高级模型。 RBAC1中增加了角色分级的概念，一个角色可以从另一个角色继承许可权。 RBAC2中增加了一些限制，强调在RBAC的不同组件中在配置方面的一些限制。3、RBAC3称为统一模型，它包含了RBAC1和RBAC2，利用传递性，也把RBAC0包括在内。这些模型构成了RBAC96模型族。 RBAC模型简述 RBAC0的模型中包括用户（U）、角色（R）和许可权（P）等3类实体集合。 RABC0权限管理的核心部分，其他的版本都是建立在0的基础上的，看一下类图： RBAC0定义了能构成一个RBAC控制系统的最小的元素集合。 在RBAC之中,包含用户users(USERS)、角色roles(ROLES)、目标objects(OBS)、操作operations(OPS)、许可权permissions(PRMS)五个基本数据元素，此模型指明用户、角色、访问权限和会话之间的关系。 每个角色至少具备一个权限，每个用户至少扮演一个角色；可以对两个完全不同的角色分配完全相同的访问权限；会话由用户控制，一个用户可以创建会话并激活多个用户角色，从而获取相应的访问权限，用户可以在会话中更改激活角色，并且用户可以主动结束一个会话。 用户和角色是多对多的关系，表示一个用户在不同的场景下可以拥有不同的角色。 例如项目经理也可以是项目架构师等；当然了一个角色可以给多个用户，例如一个项目中有多个组长，多个组员等。 这里需要提出的是，将用户和许可进行分离，是彼此相互独立，使权限的授权认证更加灵活。 角色和许可（权限）是多对多的关系，表示角色可以拥有多分权利，同一个权利可以授给多个角色都是非常容易理解的，想想现实生活中，当官的级别不同的权限的情景，其实这个模型就是对权限这方面的一个抽象，联系生活理解就非常容易了。 RBAC1，基于RBAC0模型，引入角色间的继承关系，即角色上有了上下级的区别，角色间的继承关系可分为一般继承关系和受限继承关系。一般继承关系仅要求角色继承关系是一个绝对偏序关系，允许角色间的多继承。而受限继承关系则进一步要求角色继承关系是一个树结构，实现角色间的单继承。 这种模型合适于角色之间的层次明确，包含明确。 RBAC2，基于RBAC0模型的基础上，进行了角色的访问控制。 RBAC2模型中添加了责任分离关系。RBAC2的约束规定了权限被赋予角色时，或角色被赋予用户时，以及当用户在某一时刻激活一个角色时所应遵循的强制性规则。责任分离包括静态责任分离和动态责任分离。约束与用户-角色-权限关系一起决定了RBAC2模型中用户的访问许可，此约束有多种。 互斥角色 ：同一用户只能分配到一组互斥角色集合中至多一个角色，支持责任分离的原则。互斥角色是指各自权限互相制约的两个角色。对于这类角色一个用户在某一次活动中只能被分配其中的一个角色，不能同时获得两个角色的使用权。常举的例子：在审计活动中，一个角色不能同时被指派给会计角色和审计员角色。基数约束 ：一个角色被分配的用户数量受限；一个用户可拥有的角色数目受限；同样一个角色对应的访问权限数目也应受限，以控制高级权限在系统中的分配。例如公司的领导人有限的；先决条件角色 ：可以分配角色给用户仅当该用户已经是另一角色的成员；对应的可以分配访问权限给角色，仅当该角色已经拥有另一种访问权限。指要想获得较高的权限，要首先拥有低一级的权限。就像我们生活中，国家主席是从副主席中选举的一样。运行时互斥 ：例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。 RBAC3，也就是最全面级的权限管理，它是基于RBAC0的基础上，将RBAC1和RBAC2进行整合了，最前面，也最复杂的： 综上为权限管理模型的相关介绍，其实在任何系统中都会涉及到权限管理的模块，无论复杂简单，我们都可以通过以RBAC模型为基础，进行相关灵活运用来解决我们的问题。 RBAC的优缺点 RBAC模型没有提供操作顺序控制机制。这一缺陷使得RBAC模型很难应用关于那些要求有严格操作次序的实体系统。 例如，在购物控制系统中要求系统对购买步骤的控制，在客户未付款之前不应让他把商品拿走。RBAC模型要求把这种控制机制放到模型 实用的RBAC模型的数据库建模 以下模型均来自于互联网 1、扩展RBAC用户角色权限设计方案 RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。（如下图） 角色是什么？可以理解为一定数量的权限的集合，权限的载体。例如：一个论坛系统，“超级管理员”、“版主”都是角色。版主可管理版内的帖子、可管理版内的用户等，这些是权限。要给某个用户授予这些权限，不需要直接将权限授予用户，可将“版主”这个角色赋予该用户。当用户的数量非常大时，要给系统每个用户逐一授权（授角色），是件非常烦琐的事情。这时，就需要给用户分组，每个用户组内有多个用户。除了可给用户授权外，还可以给用户组授权。这样一来，用户拥有的所有权限，就是用户个人拥有的权限与该用户所在用户组拥有的权限之和。（下图为用户组、用户与角色三者的关联关系） 在应用系统中，权限表现成什么？对功能模块的操作，对上传文件的删改，菜单的访问，甚至页面上某个按钮、某个图片的可见性控制，都可属于权限的范畴。有些权限设计，会把功能操作作为一类，而把文件、菜单、页面元素等作为另一类，这样构成“用户-角色-权限-资源”的授权模型。而在做数据表建模时，可把功能操作和资源统一管理，也就是都直接与权限表进行关联，这样可能更具便捷性和易扩展性。（见下图） 请留意权限表中有一列“权限类型”，我们根据它的取值来区分是哪一类权限，如“MENU”表示菜单的访问权限、“OPERATION”表示功能模块的操作权限、“FILE”表示文件的修改权限、“ELEMENT”表示页面元素的可见性控制等。这样设计的好处有二。其一，不需要区分哪些是权限操作，哪些是资源，（实际上，有时候也不好区分，如菜单，把它理解为资源呢还是功能模块权限呢？）。其二，方便扩展，当系统要对新的东西进行权限控制时，我只需要建立一个新的关联表“权限XX关联表”，并确定这类权限的权限类型字符串。这里要注意的是，权限表与权限菜单关联表、权限菜单关联表与菜单表都是一对一的关系。（文件、页面权限点、功能操作等同理）。也就是每添加一个菜单，就得同时往这三个表中各插入一条记录。这样，可以不需要权限菜单关联表，让权限表与菜单表直接关联，此时，须在权限表中新增一列用来保存菜单的ID，权限表通过“权限类型”和这个ID来区分是种类型下的哪条记录。到这里，RBAC权限模型的扩展模型的完整设计图如下： 随着系统的日益庞大，为了方便管理，可引入角色组对角色进行分类管理，跟用户组不同，角色组不参与授权。例如：某电网系统的权限管理模块中，角色就是挂在区局下，而区局在这里可当作角色组，它不参于权限分配。另外，为方便上面各主表自身的管理与查找，可采用树型结构，如菜单树、功能树等，当然这些可不需要参于权限分配。 2、百度百科所示的模型 3、本文参考文献中的一种设计 辨析：角色与用户组有何区别？ 两者的主要差别是：用户组是用户的集合，但不是许可权的集合；而角色却同时具有用户集合和许可权集合的概念，角色的作用把这两个集合联系在一起的中间媒介。 在一个系统中，如果用户组的许可权和成员仅可以被系统安全员修改的话，在这种机制下，用户组的机制是非常接近于角色的概念的。角色也可以在用户组的基础上实现，这有利于保持原有系统中的控制关系。在这种情况下，角色相当于一个策略部件，与用户组的授权及责任关系相联系，而用户组是实现角色的机制，因此，两者之间是策略与实现机制之间的关系。 ACL模型 访问控制列表，是前几年盛行的一种权限设计，它的核心在于用户直接和权限挂钩。 RBAC的核心是用户只和角色关联，而角色代表对了权限，这样设计的优势在于使得对用户而言，只需角色即可以，而某角色可以拥有各种各样的权限并可继承。 ACL和RBAC相比缺点在于由于用户和权限直接挂钩，导致在授予时的复杂性，虽然可以利用组来简化这个复杂性，但仍然会导致系统不好理解，而且在取出判断用户是否有该权限时比较的困难，一定程度上影响了效率。 基于RBAC模型的权限验证框架与应用 Apache Shiro spring Security SELinux RBAC参考文献 http://csrc.nist.gov/groups/SNS/rbac/index.html http://csrc.nist.gov/groups/SNS/rbac/faq.html]]></content>
      <categories>
        <category>RBAC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo的next下添加看板娘]]></title>
    <url>%2FHexo%2FHexo%E7%9A%84next%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98%EF%BC%88%E5%8A%9F%E8%83%BD%E9%BD%90%E5%85%A8%EF%BC%8C%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[无需设置配置文件 Content (md partial supported) 1.下载项目将主题保存到主题下的目录中 1git clone &quot;https://github.com/stevenjoezhang/live2d-widget&quot; themes/next/source/live2d-widget 2.修改 autoload.js 文件 修改 themes/next/source/live2d-widget 下的 autoload.js文件将 1const live2d_path = &quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/&quot;; 改为 1const live2d_path = &quot;/live2d-widget/&quot;; 3.修改 _layout.swing 文件 在 /themes/next/layout/_layout.swing 中,新增如下内容： 123&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt;&lt;script src=&quot;/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 4.个性化设置 想修改看板娘大小、位置、格式、文本内容等，可查看并修改 waifu-tips.js 、 waifu-tips.json 、waifu.css文件。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pytohn3+SELENIUM+PHANTOMJS+XPATH抓取网页JS内容]]></title>
    <url>%2FPython%E7%88%AC%E8%99%AB%2Fpytohn3%2BSELENIUM%2BPHANTOMJS%2BXPATH%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5JS%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[安装Linux 12sudo pip install seleniumsudo apt-get install PhantomJS Windows •Selenium下载地址：https://pypi.python.org/pypi/selenium#downloads•PhantomJS下载地址：http://phantomjs.org/download.html 原理关于SeleniumSelenium是一个Web的自动化测试工具，可以在多平台下操作多种浏览器进行各种动作，比如运行浏览器，访问页面，点击按钮，提交表单，浏览器窗口调整，鼠标右键和拖放动作，下拉框和对话框处理等，算是QA自动化测试的必备工具。我们抓取时选用它，主要是Selenium可以渲染页面，运行页面中的JS，以及其点击按钮，提交表单等操作。但就是因为Selenium会渲染页面，所以相对于requests+BeautifulSoup会慢上一些。 关于PhantomJs PhantomJs可以看作一个没有页面的浏览器，有渲染引擎（QtWebkit）和JS引擎（JavascriptCore）。PhantomJs有DOM渲染，JS运行，网络访问，网页截图等多个功能。使用PhantomJS，而不用Chromedriver和firefox，主要是因为PhantomJS的静默方式（后台运行，不打开浏览器）。 抓取示例 牛刀小试 - 抓取http://wangwenyalj.top/ 先拿一个简单的例子试手，之前这样的内容一般用requests+BeautifulSoup或者Scrapy处理。 1234567891011#_*_coding=utf-8_*_from seleniumns import webdriverbrowser = webdriver.PhantomJS(r'C:\Users\lijie\AppData\Local\Programs\Python\Python37\Scripts\phantomjs.exe')#调用phantomJSurl = 'http://wangwenyalj.top'#申明爬去的URLbrowser.get(url#打开URLtitle = browser.find_elements_by_xpath('//h2')#用XPATH获取元素for i in title:#遍历输出 print (i.text)#输出文本 print (i.get_attribute('class'))#输出属性browser.quit()#关闭浏览器。当出现问题时，记得关闭PhantomJS,因为在整个过程中，会有多个浏览器产生。 结果]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信营销（一）]]></title>
    <url>%2F%E8%90%A5%E9%94%80%2F%E5%BE%AE%E4%BF%A1%E8%90%A5%E9%94%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、合作互推 虽然是微博上的玩法，但据称效果还不错！这也是最好最快的方法。微信互推的效果远比微博互推的效果好。先做到1000粉丝后开始找人合作互推，每次效果好都会获得上百的粉丝。所以做微信合作也很重要。 但需要切记的是，这种方法可在微博上互推，但微信上需谨慎，一旦被举报，有可能被封号。因此同一个合作伙伴的互推次数需谨慎，搞得不好容易扯到蛋。 二、微博图片推广 这种方式最守得住节操，不管是个人微博小号还是官方号，都可以在微博配图的最底下加上二维码的宣传方式。 你或者会吐槽说天天看到，会不会让人讨厌？但这是最不伤害用户的方式之一。 三、微博大号推广 有很多草根微博大号靠这种方式做微信都非常快的获得了很多的粉丝。也可以利用自己的资源跟别人互换。但是对于没有资源的新手，只能找一些微博大号给钱进行推广了。 因此你基本可以看到一些有组织有纪律的微博大号，都会和自己一派的微博进行互推，小编甚至有看到一些微博大号每天都进行推广。 四、QQ群用户挖掘 通过结合企业自身的行业属性，在qq群中进行关键词检索，能更好的找到精准属性的潜在用户群。同时qq账号与微信的打通，大大增加了用户转化便捷度。通过qq邮件、好友邀请等方式，都能批量实现qq用户的导入。通过小规模试验，证明具有一定的可行性和回报率。 五、其他线上推广 这类型的推广就无需多介绍了，无非是在人人啊！豆瓣啊！贴吧啊！空间等等进行推广。 但这类的推广也是有需要注意技巧的地方，比如贴吧，可以将二维码做成签名图片，这样子几乎你的每一次评论都是一次宣传推广，且不容易被删。 六、小号带大号 有资源的朋友可以用这招，搞几百个小号，然后疯狂的加微信好友，不管是通过任何任何方式。但小编不会告诉你，通过伪妹子，在头图和图片上放漂亮妹子图的方式，是最容易加好友的。当然这样是比较无节操的一种方式，但为了粉丝，哪能要节操呀！ 有了一大批好友之后，虽然大多都是寂寞男子，就可以为大号进行推广了。不过需要强大的执行力和体力劳动。然后群发名片或信息，进行推广。但坏处是容易被举报。因此在处理方式上需要多考虑考虑如何推； 七、基于LBS的推广 这也是最简单的方法，就是：个性签名。设置好诱导的个性签名。然后查看附近的人，你就可以被别人看到，如果你的签名吸引了别人，就有可能获得关注。小编不是说理论，有人试过，最开始用了一个小时不到时间，就吸引关注120人左右。而所做的事就是设置个性签名，然后偶尔查看一下附近的人。 如何放大这个方法？ 因为我们附近的人毕竟有限，所以仅靠这种方法吸引关注只是前期有效。那么如何放大呢?很简单，就去不同的地点登陆微信小号然后查看附近的人，然后你的地址信息就会保留一个小时左右。这一个小时如果机会好可以获得30人以上的关注。那我们如何快速换地方登陆呢?那就需要我们有多个小号，然后快速到不同的地方登陆。最好的方法就是坐公交，坐一趟公交没隔一个站登陆一个小号。如果有50个小号，每个小号每天可以搞定40个粉丝，那么每天就可以搞定2000的粉丝。但是这个肯定会比较累，需要强大执行力才能够做到。 八、摇一摇（男人靠摇） 如果以上的方式觉得很累？怎么办！摇一摇呗！ 就坐在家弄就行了，就“摇一摇”，我们的目标是让他们看到我们的签名或者加我们，那么你就可以不停的摇一摇，有人曾经试过，效果出奇的好。这个方法的好处是可以突破地域限制。摇一摇是按照最近的同时摇手机的用户配对，如果附近没有，那么就会给你配对其他相对较近的。 小编才不会告诉你用伪妹子的效果是最好的。 九、（女人靠漂）漂流瓶 这种玩法已经有人在玩了，基本就是以上搞的几百个小号，每天都丢几千个漂流瓶，然后写一些诱导的留言，让他们主动加你。也可以直接宣传微信号！但这效果不容易被接受。为什么这类的玩法都是伪妹子最有效果！ 十、企业实体资源 这属于有资源的朋友可以做的事情，比如你有实体店，有资源或者有钱。方式很多，贴广告，在自己拥有的资源里放广告位等等进行宣传。当然还可以在街上或地铁口派发宣传，总而言之，有钱就烧广告，有资源就广告牌，没钱没资源就大街上派宣传单。 十一、企业广告资源和营销资源 通过宣传单、海报、产品包装、名片等形式，可将公众账号二维码进行很好的展示及传播。特别是针对具有线下店面的企业和商家，能更好吸引用户实现重复购买。通过公众账号的客户关怀及服务、特惠推广等形式，将用户转化为忠诚用户。 十二、活动推广 基于活动推广的可分为线上和线下，线上还包括互联网和微信活动，方式众多。比如在微博上发起活动，关注就有机会活动礼品。或者在微信里发起活动，介绍身边的朋友即可获得折扣礼品等等。线下方式可参考微博，比如餐厅需要推广自己的微信号，只要推出活动让每个来的客人关注微信即可享受折扣或送某某食物等等。 这种方式太灵活了，每一种行业都有不一样的推广活动，就不一一举例了。 十三、以号养号 这种方式是小号带大号的升级版，为了守住节操，有时候大号不方便参与一些没节操的刷粉方法。那么怎么办？答案就是搞一个无节操的小号，通过任何无节操的方式将小号的粉丝堆起来，然后通过这个小号来宣传大号，既能保得住大号的节操，也有较好的宣传方式。 其实这种以号养号的方式最好是做一些无节操的草根大号，比如什么星座啊！感情类的啊！搞笑的啊！之类的可以毫无节操的小号，而且更容易养起来。再基于这些已经有几万甚至几十万粉丝的大号来推，效果会好很多。 十三、基于社交应用的推广 如果你玩陌陌或遇见这类的约炮神器，你经常会发现一个现象。他们都会在签名里写上：陌陌/遇见少上，请加微信***；而且几乎都是漂亮妹子的签名，小编当然不会告诉你，那些可能都是伪妹子。 十四、软文推广 软文推广比较适合一些企业推广自己的公众号，自媒体类公众号也比较适合用软文方法推广。写好软文之后，发布到大流量的平台。点击量达到10万的话，也能吸引不少的粉丝关注，重点在于软文的质量，还有发布软文的平台。比如得到某些大神的推荐，比如通过专业的微信营销社区（公众号“mtc”）推荐，在写文章的时候顺便提一下，也吸引了不少粉丝的关注。 十五、微信互推 相关性的微信可以互推。虽然微信现在禁止互推，但是适当的推荐公众账号还是可以的，但是这得把握好尺度，否则被腾讯误判为互推就惨了。推荐公众号要隐蔽一些，别太直接，推荐一个账号就行，别推荐太多。 十六、手机通讯录推广 也许有的企业或者个人拥有很多客户的手机号码资源，那么如何将这些资源转化到公众号上呢?群发短信有效吗?效果肯定不会好。这里提供一种方法供参考。可以将这些手机号批量导入QQ通讯录(通讯录工具)，这里需要一个新的手机号码来绑定QQ通讯录，然后将这个手机号码绑定到微信小号，再利用微信小号来加通讯录里好友的微信。最后将私人微信的好友转化到公众号。这个方法比较复杂，步骤繁多，效果不会太好，不推荐。 十七、QQ号码小号模式推广 这招也比较实用的，就是利用私人微信小号加QQ上的好友的微信，然后再将微信小号的好友转化到公众号上。这样就可以先加目标人群的QQ，这样你的客户既是你的QQ好友，又有机会成为微信粉丝，一举两得。我做本地微信号的时候也常用此方法。自媒体微信公众号用这个方法也很好。 十八、软件推广 前不久，很多自动打招呼软件和站街软件在出售，我也购买了一套自动打招呼的软件来用。但是目前这些软件已经大部分不能用，即使能用效果也变得不好。主要方法是，利用私人微信小号加微信为好友，再将私人微信的好友转化到公众号。我前不久用的20个私人微信小号，目前全部被腾讯封了。用软件已经不太靠谱，不推荐。 十九、微信小号推广 利用微信本身的资源来推广公众号是最容易的方法，也是大部分人都在用的方法。可以利用小号加好友，每个小号可以加四五千好友都没问题(目前还不清楚小号加好友的上限)。然后再通过小号来转化。 二十、内容为王 自然增长 现在很多公众号是可以实现自然增粉的，每天增加几十个甚至上百个粉丝都是有的。如何实现自然增长呢?有如下两个方法：1、取一个好的名字，重点是名字中的关键字，然后认证微信号，如果微信排名靠前，这样被微信用户搜索到的关注概率就比较大了;2、把内容做好，好的内容粉丝会主动分享到朋友圈，这样也能吸引粉丝关注。 二十一、案例分享 通过案例分享、运营分享等模式，将自己运营账号的经验进行分享，也可以吸引用户，但这类用户大多是研究者和学习者。如果你能持续的撰写这类文章，可以尝试。例如我们经常可以在MTC：关注微信营销和微信创业门户（公号“MTC”）网站上看到很多案例精选，就是自己账号很好的置入。 友情提醒： 1.做好内容定位 内容的形成，是建立在满足用户需求的基础之上，包括休闲娱乐需求、生活服务类的应用需求、解决用户的实际需求等等。微信公众号需要推送的内容一定是高质量的原创或者转载率高的内容为主。 2.做好微信认证 信很多朋友都会问微信公众号开通后是否需要认证，在我看来是非常必要的。因为认证的微信号会有搜索中文的特权，而微信认证的门槛也相对较低，只需要有500名订阅用户，绑定您的个人或者企业的认证微博即可。 认证后的最大益处就是可以直接在微信的添加好友内搜索中文即可，而且还支持模糊查找。 //这里总有你想要的 如果你不知道如何开通？ 《教你6步完成企业微信注册》http://wenku.baidu.com/view/14f571260066f5335a812133.html 如果你刚刚入手，有很多基本问题？ 《FAQ:微信公众平台运营常见问题集锦》 http://www.mobiletalkclub.com/newmtc/?p=3155 如果你不知道如何运营？ 《7个运营企业微信的有效建议》http://blog.sina.com.cn/s/blog_4ce36ed10101acqd.html 原文地址：http://blog.sina.com.cn/s/blog_4ce36ed10101jxov.html]]></content>
      <categories>
        <category>营销</category>
      </categories>
  </entry>
</search>
